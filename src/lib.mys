from string import StringReader
from string import pretty

class GraphqlError(Error):
    message: string

@trait
class _Token:
    pass

class _Punctuator(_Token):
    value: char

class _Name(_Token):
    value: string

class _IntValue(_Token):
    value: string

class _FloatValue(_Token):
    value: string

class _StringValue(_Token):
    value: string

class _Tokens:
    _tokens: [_Token]
    _pos: u64

    func __init__(self, tokens: [_Token]):
        self._tokens = tokens
        self._pos = 0

    func available(self) -> bool:
        return self._pos < len(self._tokens)

    func get(self) -> _Token:
        self._pos += 1

        return self._tokens[self._pos - 1]

    func peek(self) -> _Token:
        return self._tokens[self._pos]

class Document:
    definitions: [Definition]

class Definition:
    executable_definition: ExecutableDefinition

class ExecutableDefinition:
    operation_definition: OperationDefinition

class OperationDefinition:
    selections: [Selection]

class Selection:
    field: Field

class Field:
    name: string
    arguments: [Argument]
    selections: [Selection]

class Argument:
    name: string

func _tokenize_name(reader: StringReader) -> _Token:
    name = ""

    while True:
        ch = reader.get()

        if ch.is_alpha() or ch == '_':
            name += ch
        else:
            if ch != '':
                reader.unget()

            break

    return _Name(name)

func _tokenize_number(reader: StringReader) -> _Token:
    value = ""

    while True:
        ch = reader.get()

        if ch.is_digit():
            value += ch
        else:
            if ch != '':
                reader.unget()

            break

    return _IntValue(value)

func _tokenize_string(reader: StringReader) -> _Token:
    value = ""

    while True:
        ch = reader.get()

        if ch == '\"':
            break
        elif ch == '':
            raise GraphqlError("No end of string.")
        else:
            value += ch

    return _StringValue(value)

func _tokenize(document: string) -> _Tokens:
    reader = StringReader(document)
    token: _Token = None
    tokens: [_Token] = []

    while True:
        ch = reader.get()

        if ch in ",\t\r\n ":
            continue
        elif ch in "!$&():=@[]{|}":
            token = _Punctuator(ch)
        elif ch == '.':
            raise GraphqlError(f"Unsupported character '{ch}'")
        elif ch == '-' or ch.is_digit():
            reader.unget()
            token = _tokenize_number(reader)
        elif ch == '\"':
            token = _tokenize_string(reader)
        elif ch.is_alpha() or ch == '_':
            reader.unget()
            token = _tokenize_name(reader)
        elif ch == '':
            break
        else:
            raise GraphqlError(f"Invalid character '{ch}'")

        tokens.append(token)

    return _Tokens(tokens)

func _parse_arguments(tokens: _Tokens) -> [Argument]:
    match tokens.peek():
        case _Punctuator(value='('):
            pass
        case _:
            return None

    tokens.get()
    arguments = []

    while True:
        match tokens.get():
            case _Name() as name_token:
                arguments.append(Argument(name_token.value))

                match tokens.get():
                    case _Punctuator(value=':'):
                        pass
                    case _:
                        raise GraphqlError("No :.")

                tokens.get()
            case _Punctuator(value=')'):
                break
            case _:
                raise GraphqlError("No ).")

    return arguments

func _parse_name(tokens: _Tokens) -> string:
    match tokens.get():
        case _Name() as name_token:
            return name_token.value
        case _:
            return None

func _parse_field(tokens: _Tokens) -> Field:
    name = _parse_name(tokens)

    if name is None:
        return None

    arguments = _parse_arguments(tokens)
    selections = _parse_selection_set(tokens)

    return Field(name, arguments, selections)

func _parse_selection(tokens: _Tokens) -> Selection:
    return Selection(_parse_field(tokens))

func _parse_selection_set(tokens: _Tokens) -> [Selection]:
    selections: [Selection] = []

    match tokens.peek():
        case _Punctuator(value='{'):
            pass
        case _:
            return None

    tokens.get()

    while True:
        match tokens.peek():
            case _Punctuator(value='}'):
                break

        selection = _parse_selection(tokens)

        if selection is None:
            return None

        selections.append(selection)

    tokens.get()

    return selections

func _parse_operation_definition(tokens: _Tokens) -> OperationDefinition:
    return OperationDefinition(_parse_selection_set(tokens))

func _parse_executable_definition(tokens: _Tokens) -> ExecutableDefinition:
    return ExecutableDefinition(_parse_operation_definition(tokens))

func _parse_definition(tokens: _Tokens) -> Definition:
    return Definition(_parse_executable_definition(tokens))

func _parse_document(tokens: _Tokens) -> Document:
    document = Document([])

    while tokens.available():
        document.definitions.append(_parse_definition(tokens))

    return document

func parse(document: string) -> Document:
    """Parse given document.

    """

    tokens = _tokenize(document)

    return _parse_document(tokens)

@test
func test_parse_query():
    document = parse("\t\r"
                     "{\n"
                     "  foo(id: 10, name: \"kalle\") {\n"
                     "    id\n"
                     "    name\n"
                     "    value\n"
                     "  }\n"
                     "}")
    assert len(document.definitions) == 1
    selections = (document
                  .definitions[0]
                  .executable_definition
                  .operation_definition
                  .selections)
    assert len(selections) == 1
    selection = selections[0]
    assert selection.field.name == "foo"
    arguments = selection.field.arguments
    assert len(arguments) == 2
    assert arguments[0].name == "id"
    assert arguments[1].name == "name"
    selections = selection.field.selections
    assert len(selections) == 3
    assert selections[0].field.name == "id"
    assert selections[0].field.arguments is None
    assert selections[0].field.selections is None
    assert selections[1].field.name == "name"
    assert selections[1].field.arguments is None
    assert selections[1].field.selections is None
    assert selections[2].field.name == "value"
    assert selections[2].field.arguments is None
    assert selections[2].field.selections is None

@test
func test_spacex():
    document = parse("{"
                     "  launchesPast(limit: 10) {"
                     "    mission_name"
                     "    launch_date_local"
                     "    launch_site {"
                     "      site_name_long"
                     "    }"
                     "    ships {"
                     "      name"
                     "      home_port"
                     "      image"
                     "    }"
                     "  }"
                     "}")
    assert len(document.definitions) == 1
    selections = (document
                  .definitions[0]
                  .executable_definition
                  .operation_definition
                  .selections)
    assert len(selections) == 1
    assert selections[0].field.name == "launchesPast"
    selections = selections[0].field.selections
    assert selections[0].field.name == "mission_name"
    assert selections[1].field.name == "launch_date_local"
    assert selections[2].field.name == "launch_site"
    assert selections[2].field.selections[0].field.name == "site_name_long"
    assert selections[3].field.name == "ships"
    assert selections[3].field.selections[0].field.name == "name"
    assert selections[3].field.selections[1].field.name == "home_port"
    assert selections[3].field.selections[2].field.name == "image"
